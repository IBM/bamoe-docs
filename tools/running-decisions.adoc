= Running Decisions
include::../partials/attributes.adoc[]
 
Developing a Decision can be very complex, depending on the number of rules you have on Decision Tables and the possibilities you have available with the many values that compose its inputs.
{CANVAS} allows you to run your Decisions while developing them, making it easy for you to test scenarios and reproduce them after you make changes.
It's also very useful for quickly evaluating a set of inputs.
We call this capability of running Decisions while developing them "DMN Runner".

When you open the Editor page for Decisions, you have an extra “Run” button available at the top-right, as you see in the figure below.
Clicking this button will open the DMN Runner panel, in either Form or Table mode.
You can easily switch between the modes by clicking the Table icon in the first column of the Form mode and by clicking the Form icon in the Table rows individually.

Let's create a new Decision from one of the Samples provided by {CANVAS}.
On the Home screen, select “Try sample” on the Decision card.
When you click the “Run” button, you'll see the screen below.
Let's see what those elements are.

.Editor page for a Decision on {CANVAS} with highlighted elements of the DMN Runner in Form mode
image::tools/image15.jpg[]

. *Run button* → Lets you show/hide DMN Runner panels.
  Clicking the arrow lets you select the mode you want -- Table or Form.
  It's also possible to download, load, or delete inputs.
  Deleting inputs is a permanent operation and cannot be undone.
. *Add input row button* → Clicking this button will create a new set of inputs.
  In Form mode, you can only see one "row" at a time.
  To see all your input rows at the same time, switch to Table mode.
. *Table mode button* → Switches DMN Runner to Table mode.

Let's add a new input row, switch to Table mode, and look at the DMN Runner elements.

.Editor page for a Decision on {CANVAS} with highlighted elements of the DMN Runner in Table mode
image::tools/image11.jpg[]

. *Show row in Form mode button* → Switches DMN Runner to Form mode and displays the selected row.
. *“Run” tab* → Lets you quickly show/hide the DMN Runner Table.
  Clicking this button is the same as clicking the "Run" button at the top right.

DMN Runner remembers the mode you used for each file, so if you use the File switcher to move between files, you can see DMN Runner switching modes, depending on the last mode you used for each file.

Now that you're familiar with the DMN Runner controls, running your Decision with your input rows is easy.
Just fill in the input fields and see the results live in the Outputs column in Form mode, or the right-hand-side Table in Table mode.

If you're familiar with the DMN Boxed Expression Editor, you'll be very comfortable navigating through the DMN Runner Table, as they share the same Table component.

DMN Runner will infer the type of your inputs from their Data Types.
We encourage you to keep your Data Types organized for better maintainability of your Decision, and to extract the most of what DMN Runner has to offer.

Loading an input file with unmatching input names and/or Data Types will ignore the unmatching inputs.

== Limitations

* Recursive Struct Data Types are not yet supported.
  You'll see a placeholder component where the inputs should be if you have one of those in your Decision.
* Your input data is not versioned as part of your repository, and it is only persisted in your browser.
  They are saved to your disk, so you can safely close your tabs and restart your computer.
  If you want to share a set of inputs, use the "Download inputs" and the "Load inputs" buttons in the "Run" dropdown.
* Undo/redo operations are not yet supported on the DMN Runner.
* Changing a Data Type can potentially erase all the values you have for an input.
* Renaming an input will delete the input values previously saved.

== Reusing logic
For solving a problem in any domain, it is always helpful to be able to reuse some existing logic.
To make some logic reusable in the DMN, we use BKM or Decision Service nodes.

=== Reusing logic - Decision Service
We will take a closer look at the Decision Service node.
Using this node, we will define a logic that can be reused unlimitedly in our DMN models or models that will import our Decision Service node.

The Decision Service node allows for the wrapping and structuring of a larger set of Decision nodes while producing a single output.
We will not start from scratch.
Rather, we will reuse an existing community example, https://raw.githubusercontent.com/apache/incubator-kie-kogito-examples/8123b27b7fb64d6a0a4c4561d97487e2b6253cf7/kogito-quarkus-examples/onboarding-example/payroll/src/main/resources/org/kie/kogito/examples/payroll/taxRate.dmn[taxRate.dmn].

NOTE: The `taxRate.dmn` link was introduced with {PRODUCT_SHORT} 9.1.0. and you may update the url commit sha accordingly or simply search for that file in the github repository to see the latest version.

After opening `taxRate.dmn`, you will see a node `rate` containing two nodes `compute Payroll` and `taxRate`.
However, using only one **encapsulated** node `taxRate` and one **output** node `compute Payroll` does not sufficiently demonstrate the power of the Decision Service node.
Therefore, we will build on this example by adding more nodes.

As a first step, move `compute Payroll` node out of the `rate` node and remove its connection with the `taxRate` node.
We will use this node later to invoke the logic wrapped in the Decision Service node.
We can also change the model name from `taxes` to `payroll`.

image::tools/runningDecisions/reusing-logic-checkpoint-1.png[]

Now, let's make the Decision Service node `rate` bigger, as we will add more content to it.
We will introduce a logic similar to the `taxRate` node for computing vacation days and payment dates.
Please add two new Decision nodes into the **output** section of the `rate` node and name them as: `vacationDays` and `paymentDate`.
Connect the existing `employee` node with both added nodes.
Move also the existing `taxRate` node from the **encapsulated** into the **output** section.

image::tools/runningDecisions/reusing-logic-checkpoint-2.png[]

We successfully changed the structure of the logic.
By moving all Decision nodes into the **output** section, the Decision Service node will now return Complex data instead of Simple data.

NOTE: See xref:authoring-decisions.adoc#adding-a-data-type[Adding a data type] to learn more about data types.

Now, we need to define logic for the new nodes.
Set the `vacationDays` and `paymentDate` data type to `number`.
We do not use `date` for the `paymentDate` because in our example the `paymentDate` is a day of the month.

Both `vacationDays` and `paymentDate` will be implemented as a decision table very similar to the `taxRate` decision table.
It is a good opportunity to use the copy and paste feature we have.
This feature is available by clicking the top left corner of the node expression.

image::tools/runningDecisions/reusing-logic-checkpoint-3.png[]

In other words, click on the node expression type.
Copy the existing `taxRate` expression and paste it into `vacationDays` and `paymentDate` nodes or create the decison tables from scratch.

NOTE: If you decided to use the copy and paste feature, you will need to rename the nodes back to `vacationDays` and `paymentDate`.

Let's finish the new decision tables.
Let's return **38** vacation days for **"US"** and **"33"** vacation days for **"UK"**.
Let's return **15** as a payment date for **"US"** and **"10"** as a payment date for **"UK"**.

For a moment, switch to the **Data types** tab.
Add new Complex type `tPayroll` with these properties: `taxRate: number`, `vacationDays: number` and `paymentDate: number`.

NOTE: See xref:authoring-decisions.adoc#adding-a-data-type[Adding a data type] to learn more about Complex data types.

image::tools/runningDecisions/reusing-logic-checkpoint-3.png[]

Switch back to the **Editor** tab.
Rename the `rate` node to `payroll` and sets its Data type as `tPayroll`.
Now connect the `payroll` with the `compute Payroll`.

Open the `compute Payroll` node and **Reset** its expression to be an **Invocation**.
For the Invocation we need to specify the function name as `payroll` and the single parameter as `employee`, with a passed value of `employee`.
In this case, the `compute Payroll` Data type will be `tPayroll` and the `employee` Data type will be `tEmployee`.

NOTE: The complete list of parameters that a Decision Service node requires to be invoked can be also seen in the Properties panel **Invoking this Decision Service in FEEL** section.

image::tools/runningDecisions/reusing-logic-checkpoint-4.png[]

Then if we open the **DMN Runner** and input the employee's country, we should see the payroll computed accordingly.

There is available source code of the https://raw.githubusercontent.com/bamoe/bamoe-docs-source-code-examples/9.1.x/dmn/payroll.dmn[payroll.dmn] example model.

image::tools/runningDecisions/reusing-logic-checkpoint-5.png[]
