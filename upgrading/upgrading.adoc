= Upgrading from 9.1.x
include::../partials/attributes.adoc[]

You can upgrade your existing business automation applications and platforms to the most recent version of {PRODUCT_LONG}. If you are upgrading from an older version, you must follow the steps to upgrade to each intermediate version, as documented. Depending on the complexity of your installation, you might want IBM(R) Services to participate in your project. If so, contact your IBM service representative.

If you want to know more on how to upgrade from version {VERSION_90X} to version {VERSION_91X}, see https://ibmdocs-test.dcs.ibm.com/docs/en/ibamoe/9.1.x?topic=upgrading[Upgrading]

// The above link to Upgrade has to be changed to external site during release 

You can upgrade your project in the following two ways by:

* Creating a new project from scratch and moving your existing assets to it.
* Updating an existing BAMOE version {VERSION_91X} project.
You will start by setting up the Maven configuration.

== Prerequisites

The following tools are required to upgrade to {PRODUCT_SHORT} version {VERSION_920}:

- https://openjdk.org[JDK 17] or later is installed.
- https://maven.apache.org[Apache Maven 3.9.6] or later is installed.
- https://code.visualstudio.com/download[Visual Studio Code IDE] latest version


== Step 1: Download Product Archives

The first step in upgrading is to download the product archives from either {PRODUCT_FIX_CENTRAL_PAGE_LINK}[IBM Fix Central] _(which requires an active support subscription to {PRODUCT})_ or via the {DEV_PROGRAM_PAGE_LINK}[IBM Business Automation Manager Open Editions Developer Program] _(subject to its terms)_.
Download the files based on your requirement.
The following table shows the most common files but you can select other files according to your environment.


.{PRODUCT_SHORT} Product Archives

The following archives are typically used in upgrading to {PRODUCT_SHORT}:

.Common Product Archives
|===
| Product Archive | Description

| bamoe-**{VERSION**}-maven-repository-image.tar.gz   
| BAMOE Maven repository image contains many of the artifacts that Java developers typically use to build their applications.

| bamoe-**{VERSION**}-management-console-image.tar.gz 
| The {MANAGEMENT_CONSOLE} Image provides a user interface for managing process instances.

| bamoe-**{VERSION**}-developer-tools.zip   
| {DEV_TOOLS} to create, edit and visualize business processes (BPMN), decisions (DMN), test scenarios (SceSim), and generate web forms used during workflow execution.

| bamoe-**{VERSION**}-standalone-bpmn-and-dmn-editors-classic.tgz   
| BPMN and DMN Editors (classic) are available enabling you to embed the BPMN and DMN Editors in your applications.

| bamoe-**{VERSION**}-standalone-dmn-editor.tgz   
| The new Standalone DMN Editor is available enabling you to embed the DMN editors in your applications.

| bamoe-**{VERSION**}-sources.zip   
| Source code of the product artifacts.

| bamoe-**{VERSION**}-container-sources.zip 
| Source code of the product container images.

| bamoe-**{VERSION**}-maven-repository.zip   
| The Maven repository contains many of the artifacts that Java developers use to build their applications.

| bamoe-**{VERSION**}-licenses.zip   
| No additional information.

| bamoe-**{VERSION**}-examples.zip
| The Business Automation Manager Open Editions (BAMOE) examples include example applications which contain various types of services to help you develop your own applications. The services use one or more Decision Model and Notation (DMN) decision models, Drools Rule Language (DRL) rule units, Predictive Model Markup Language (PMML) models, or Java classes to define the service logic.

For information about each example application and instructions for using them, see the README file in the relevant application folder.

| bamoe-**{VERSION**}-canvas-helm-chart.tgz
| A Helm Chart that allows to install {CANVAS} and its related services with a single command: Helm, the package manager for Kubernetes.

| bamoe-**{VERSION**}-canvas-docker-compose.zip
| This package contains the 'docker-compose' file to run {CANVAS} and all related services.

| bamoe-**{VERSION**}-cors-proxy-image.tar.gz
| This image provides a proxy to allow {CANVAS} web app to communicate with Git providers, like github.com and GitHub Enterprise.

| bamoe-**{VERSION**}-canvas-image.tar.gz
| {CANVAS} is a web application that provides authoring tools for Decisions and Workflows, directly in the browser.

| bamoe-**{VERSION**}-extended-services-image.tar.gz
| This image provides features like DMN Runner, static validation of DMN, BPMN models, and also provides a proxy to communicate with OpenShift and Kubernetes clusters.

| bamoe-**{VERSION**}-canvas-dev-deployment-upload-service.zip
| The {CANVAS} Dev Deployment Upload Service runs an HTTP server that accepts ZIP file uploads to the `/upload` endpoint, with the correct `?apiKey=<key>` query param. When an upload is done, the application will unzip the file at the configured location and exit with a 0 code, or 1 otherwise.

| bamoe-**{VERSION**}-canvas-dev-deployment-base-image.tar.gz
| Docker image with Java and Maven, as well as the `canvas-dev-deployment-upload-service` binary pre-installed and ready to be used. This image doesn't run any services, and is only used to provide a basis for other Dev Deployment images that want a starting point, taking advantaged of the included `canvas-dev-deployment-upload-service`.

| bamoe-**{VERSION**}-canvas-dev-deployment-quarkus-blank-app-image.tar.gz
| This image is ready to be used for Dev deployments on {CANVAS}. It starts the `dev-deployment-upload-service` and then places the uploaded files inside a blank Quarkus app. These files can be Decisions (`.dmn`) or Processes (`.bpmn`), all of them will be used as resources for the app.

| bamoe-**{VERSION**}-canvas-dev-deployment-dmn-form-webapp-image.tar.gz
| This image is ready to be used for Dev deployments that contain Decisions (`.dmn`) on {CANVAS}. It expects a Quarkus application to be running at the same host, which it will use to fetch information to render a form that let users interact with a Decision.

|===

[NOTE]
====
In the displayed table, you must replace VERSION with the version of IBM Business Automation Manager you are upgrading to, such as 9.2.0.

====
Now that you have the files, you can start the upgrading process.


== Step 2: Update Maven configuration and settings

{MAVEN_SITE_LINK}[Apache Maven] is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage the build, reporting and documentation of a project from a central piece of information.
{PRODUCT_LONG} depends on Maven to build various types of deployable artifacts, such as decision service applications.
For a quick start, see the {MAVEN_SITE_GETTING_STARTED_LINK}[Maven Quick Start Guide].  

Since {PRODUCT_SHORT} version {VERSION} is based on Quarkus 3.15, the easiest route is to use the Quarkus Maven Plugin and adjust some of the details in the generated project to align it with {PRODUCT_SHORT} dependencies and plugins.
You can read all about **Quarkus and Maven** https://quarkus.io/guides/maven-tooling[here].

The dependencies are distributed with a container image or a zip file.
Refer to {PRODUCT_SHORT} version {VERSION} xref:../installation/configure-maven.adoc[Maven configuration].


== Step 3: Updating your development environment

When you update your development environment, you must update {CANVAS} and {DEV_TOOLS}. 

=== Upgrading {CANVAS}

Before you update {CANVAS}:

- Save your existing projects to the browser.
- Install your new version of {CANVAS} by replacing your existing installation or by using the blue-green deployment strategies (https://docs.openshift.com/container-platform/4.14/applications/deployments/route-based-deployment-strategies.html#deployments-blue-green_route-based-deployment-strategies[blue/green deployment strategies]). 

If you want to know how to install {CANVAS}, see xref:../installation/installation.adoc[Installing]

- If you have installed a parallel version, use {CANVAS} Import functionality to import your saved projects. See xref:../tools/importing-existing-projects.adoc[Importing existing projects]

To know more on projects, see Step 4a.

=== Upgrading {DEV_TOOLS}

The {DEV_TOOLS} will automatically update as long as you have set this option in VS Code.

To set this option, go to Visual Studio Code, click Extensions and then select the {DEV_TOOLS}. You will see a checkbox 'Auto Update' on the page. Click it to set. This will take care of your updates automatically. See xref:../tools/developer-tools-for-vscode.adoc[{DEV_TOOLS}] to know more.

[NOTE]
====
After upgrading, the new DMN Editor will be opened automatically when you first access it in {CANVAS} or {DEV_TOOLS}.
Existing DMN files (any version) can be opened directly in the editor. For more information, see xref:../editing/authoring-decisions.adoc[Authoring decisions].

====

== Step 4a: Creating a new project from scratch

Now that you have Maven properly configured, you can create a new Maven project to upgrade your existing business automation assets to the new {PRODUCT_SHORT} version {VERSION}.
There are several ways to create Maven projects; this approach uses a published Maven plugin.

[start=1]
. In a terminal window, create a new local folder for the new Maven project, for example, `/Users/developer`, and navigate to that folder.

. Create the project using Quarkus and the following Maven commands. 
This creates a Quarkus project called `my-sample-decision-service`, which is versioned `1.0.0-SNAPSHOT`, and includes the extensions `resteasy-reactive-jackson, quarkus-smallrye-openapi, quarkus-smallrye-health`.
+
[source,console,subs="+attributes"]
----
mvn io.quarkus.platform:quarkus-maven-plugin:3.8.6:create \
    -DprojectGroupId=com.ibm.bamoe.samples \
    -DprojectArtifactId=my-sample-decision-service \
    -DprojectVersion=1.0.0-SNAPSHOT \
    -DplatformGroupId=io.quarkus.platform \
    -DplatformArtifactId=quarkus-bom \
    -Dextensions=resteasy-reactive-jackson,quarkus-smallrye-openapi,quarkus-smallrye-health
----
+
[NOTE]
====
As you can see from the Maven command, there are a number of possible `extensions` that can be added to the project for the specific functionality. 
You can find more information on available extensions at the following locations:  https://quarkus.io/extensions/[Quarkus Extensions], and https://quarkus.io/extensions/?search-regex=kogito[Kogito Extensions].
====
+
When you create this project, you will notice the Maven artifacts being streamed in your console as they are pulled. When the process is complete, you will see a console message like the following:
+
[source,console]
----
[INFO]
[INFO] ========================================================================================
[INFO] Your new application has been created in /Users/developer/my-sample-decision-service
[INFO] Navigate into this directory and launch your application with mvn quarkus:dev
[INFO] Your application will be accessible on http://localhost:8080
[INFO] ========================================================================================
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  2.632 s
[INFO] Finished at: 2024-06-11T11:20:51-03:00
[INFO] ------------------------------------------------------------------------
----

[start=3]
.  Add the following `properties` to the `pom.xml` file, using the row numbers as a guide.
This specifies the Maven coordinates for the {PRODUCT_SHORT} Maven Bill-of-Materials (BOM), which manages all of the associated dependency versions for a specific {PRODUCT_SHORT} release:
+
[source,xml,subs="attributes+"]
----
<properties>
  <surefire-plugin.version>3.0.0-M7</surefire-plugin.version>
  <kogito.bom.group-id>com.ibm.bamoe</kogito.bom.group-id>
  <kogito.bom.artifact-id>bamoe-bom</kogito.bom.artifact-id>
  <kogito.bom.version>{BOM_VERSION}</kogito.bom.version>
</properties>
----

[start=4]
. Replace lines 31-37, which essentially add the `bamoe-bom` to the list of imported dependencies:
+
[source,xml]
----
 <dependency>
   <groupId>${kogito.bom.group-id}</groupId>
   <artifactId>${kogito.bom.artifact-id}</artifactId>
   <version>${kogito.bom.version}</version>
   <type>pom</type>
   <scope>import</scope>
 </dependency>
----
+
A bill of materials (BOM) is a list of parts or components that are required to build a product.
BOMs are ordinary `pom.xml` files that contain no source code, and their only purpose is to declare their bundled modules.

.Always use the Maven Bill-of-Materials (BOM)
[IMPORTANT]
====
It is recommended to use a bill of materials (BOM) to manage project dependencies, as it simplifies dependency management by organizing a group of dependencies under a single version. 

The use of a Maven bill-of-materials (BOM) does not add any dependencies to the project.
Rather, it functions as a reference for managing the versions of your project dependencies (and transient dependencies).
====    

A bill of materials (BOM) can be added to an existing POM file by adding it to the **_dependencyManagement_** section as a dependency with a pom type:

include::../partials/maven-bom-now.adoc[]

When a bill of materials (BOM) is used, it is not necessary to specify the version of the dependency, as that appears from the BOM, so your dependencies will resemble the following:

[source,xml]
----
<dependencies>
  <dependency>
    <groupId>org.drools</groupId>
    <artifactId>drools-compiler</artifactId>
  </dependency>
</dependencies>
----

[NOTE]
====
During the course of your Maven dependency update, if you encounter any dependencies that are not included in the bill of materials (BOM) please report it to IBM to be resolved.
====

See xref:../introduction/release-notes/version-mapping.adoc[version mapping for {PRODUCT_SHORT} version {VERSION_91X}].

[start=5]
. Add the `IBM ILMT Compliance Library` to the `pom.xml`  _(this is required  to report on subscription entitlement usage within the system)_:
+
[source,xml]
----
<dependencies>
  <dependency>
    <groupId>com.ibm.bamoe</groupId>
    <artifactId>bamoe-ilmt-compliance-quarkus-dmoe</artifactId>
  </dependency>
</dependencies>
----

[NOTE]
====
You might notice that the newly added Maven dependency includes the `groupId` and `artifactId` portions of the Maven coordinates but does not specify a `version` tag.
This is due to importing the `bamoe-bom` into the project, where the various dependency versions are managed.
====

[start=6]
. Add the dependencies.
+
For this example, you will be creating a project with only DMN files.
So you must add the `drools-quarkus-decisions` dependency.
In the {PRODUCT_SHORT} version {VERSION} some dependencies had a slight name change, see section, 'Maven libraries mapping guide' and update accordingly.
+
[source,xml]
----
45 <dependency>
46   <groupId>org.drools</groupId>
47   <artifactId>drools-quarkus-decisions</artifactId>
48 </dependency>
----
+
[NOTE]
====
Depending on the project files you may be required to add other dependencies.
====

[start=7]
. Disable Quarkus Dev Services.
+
Currently, the Quarkus Dev Services is not fully supported and hence it is required to disable this feature by adding the following line to the `src/main/resources/application.properties` file:
+ 
[source]
----
quarkus.devservices.enabled=false
----

[start=8]
. Build the project in the root folder:
+ 
[source,shell]
----
mvn clean package
----
+
You might get Maven streaming text once again, and at the end of it you will see:
+
[source,shell]
----
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  8.023 s
[INFO] Finished at: 2024-06-11T17:09:00-03:00
[INFO] ------------------------------------------------------------------------
----
+
[NOTE]
====
The choice of extensions determines the imported behavior of the project including adding sample models or testing related code.
====

[start=9]
. Add and update Business Automation assets
+
After the project is generated, you will see a project structure in VS Code, similar to the following diagram:
+
.Example Maven Project in VS Code
image::maven-project.png[Example Maven project in VS Code]
+
As you can see from the figure, a Maven compliant project is generated, including all of the standard folders typically found in a Maven project.
The most significant folder is the `resources` folder, which is where new or upgraded business automation asset files must be stored.
Examples of supported business automation assets are:
+
- Decision Model & Notation (DMN) decisions (.dmn)
- Drools Rule Language (DRL) rules (.drl)
- Business Process Modeling & Notation (BPMN) workflows (.bpmn)
- Excel Decision Tables Excel files (.xlsx)
- Standard Properties files (.properties)
- Test Scenario files (.scesim)
+
[NOTE]
====
The proper folder for unit test files is `src/test/resources`, as this is a testing resource.
====
+
Now, copy all your assets from the {PRODUCT_SHORT} version {VERSION_901} project to the respective folders on the new project.
As the new project uses Quarkus 3, you must make a few more updates.
One of the biggest changes is that Quarkus 3 uses Jarkarta EE 10. You need to update all `javax` to `jakarta`.
This is simply achieved by replacing any `javax` instance over `jarkarta`, like the following:
+
[source,diff]
----
 --- import javax.inject.Named;
 +++ import jakarta.inject.Named;
----
+
[NOTE]
====
Refer https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.0[Quarkus v3 migration guide] for any other change that is related to Quarkus.
====

[start=10]
. Build the project one more time.
+
[source,console]
----
mvn clean package
----
+
You might get Maven streaming text once again, and at the end of it you must have:
+
[source,console]
----
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  8.023 s
[INFO] Finished at: 2024-06-11T17:09:00-03:00
[INFO] ------------------------------------------------------------------------
----
+
Now you can start using your {PRODUCT_SHORT} version {VERSION} project.

=== Add Business Automation Assets

If your project is upgraded from a previous version of the product, you can add the business automation files from the previous project to the `src/main/resources` folder of the new project by copying the files.
If you need to create a new file, use `File : New File` option from VS Code, making sure to specify the file extension to associate the new file with the appropriate editor.

== Step 4b: Upgrading a version {VERSION_90X} project

Upgrading a {PRODUCT_SHORT} version {VERSION_91x} project to version {VERSION} is straightforward.
The project structure is not changed, updates only need to be made to the project versions, some dependency names, and files.

[start=1]
. Upgrade the Quarkus version in the project POM file
+
In the {PRODUCT_SHORT} version {VERSION_90X} the Quarkus version was 2.16 and for version {VERSION} it is 3.8.6.
To make this upgrade, open the `pom.xml` file and do the following change:
+
[source,xml]
----
 ---   <quarkus-plugin.version>2.16.10.Final</quarkus-plugin.version>
 +++   <quarkus-plugin.version>3.8.6</quarkus-plugin.version>
       <quarkus.platform.artifact-id>quarkus-bom</quarkus.platform.artifact-id>
       <quarkus.platform.group-id>io.quarkus</quarkus.platform.group-id>
 ---   <quarkus.platform.version>2.16.12.Final</quarkus.platform.version>
 +++   <quarkus.platform.version>3.8.6</quarkus.platform.version>
----

[start=2]
. Upgrade the BOM and Kogito versions.
+
Previously, the {PRODUCT_SHORT} version {VERSION_90X} used the BOM version {BOM_VERSION_901} and Kogito version {KOGITO_VERSION_901}.
Now, both versions are {BOM_VERSION_911}.
Update the following lines in your `pom.xml`:
+
[source,xml,subs="attributes+"]
----
       <kogito.bom.artifact-id>bamoe-bom</kogito.bom.artifact-id>
 ---   <kogito.bom.version>{BOM_VERSION_901}</kogito.bom.version>
 ---   <version.org.kie.kogito>{KOGITO_VERSION_901}</version.org.kie.kogito>
 +++   <kogito.bom.version>{BOM_VERSION_911}</kogito.bom.version>
 +++   <version.org.kie.kogito>{KOGITO_VERSION_911}</version.org.kie.kogito>
----

[start=3]
. Update the dependencies GAV.
+
In the {PRODUCT_SHORT} version {VERSION} some dependencies had a slight name change, see section, 'Maven libraries mapping guide' and update accordingly.
+
One of the renamed dependencies is the `groupdId=org.kie.kogito` and `artifactId=kogito-quarkus`, which was renamed to `groupdId=org.jbpm` and `jbpm-with-drools-quarkus`.
+
[source,xml]
----
       <dependency>
 ---     <groupId>org.kie.kogito</groupId>
 ---     <artifactId>kogito-quarkus</artifactId>
 +++     <groupId>org.jbpm</groupId>
 +++     <artifactId>jbpm-with-drools-quarkus</artifactId>
       </dependency>
----
+
Depending on your project setup you may also need to make changes to a parent `pom.xml`if it exists. This is not covered here.

[start=4]
. Update the `application.properties` file.
+
{PRODUCT_SHORT} version {VERSION} does not fully support the Quarkus Dev Services and hence it is required to disable this feature by adding the following line to the `src/main/resources/application.properties` file:

+
[source,diff]
----
 +++ quarkus.devservices.enabled=false
----

[start=5]
. Upgrading the code to Quarkus 3.
+
A major Quarkus 3 change, is the usage of Jakarta EE 10, meaning that package imports also need to update from `javax` to `jakarta`.
+
This is simply achieved by replacing any `javax` instance over `jarkarta`, like the following:
+
[source,diff]
----
 --- import javax.inject.Named;
 +++ import jakarta.inject.Named;
----
+
[NOTE]
====
Refer https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.0[Quarkus v3 migration guide] for any other change that is related to Quarkus.
====

[start=6]
. Build the project in the root folder:
+
[source,console]
----
mvn clean package
----
+
You might get Maven streaming text once again, and at the end you will see:
+
[source,console]
----
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  8.023 s
[INFO] Finished at: 2024-06-11T17:09:00-03:00
[INFO] ------------------------------------------------------------------------
----
+

[NOTE]
====
After completing the upgrade of the project, you might want to consider upgrading your technical rules to use new language features, such as `rule units` and `OOPATH syntax`.
Refer to xref:drl.html[Drools Rule Language Migration] for information on upgrading to the latest version of Drools Rule Language (DRL).
====

Now, you can start using your {PRODUCT_SHORT} version {VERSION} project.

== Step 5: Update your runtime environment

You need to update your business services and {MANAGEMENT_CONSOLE}. 

You can follow the standard guidance on how to maintain your business service project, including how to build using Maven and how to deploy to your target Kubernetes-based environment.
This includes not only creating and publishing the new project to an enterprise GIT repository but also configuring your CI/CD pipeline to pull from GIT and performing a Maven build/test/deploy, etc.

To update your {MANAGEMENT_CONSOLE} installation, see xref:../installation/management-console.adoc[Installing → {MANAGEMENT_CONSOLE}].


== [#migrate-tech-preview]Migrating from the {VERSION_911} Technology Preview

In the {VERSION_911} technology preview the general Process API was used to call your stateful process. In this version a new User Tasks API is built on top of the
a dedicated User Tasks subsystem. As a direct impact of that there are three key changes to be taken into account:

* The new API does not require global parameters related to the whole process (such as `processID`, `process Instance ID` and `task name`. The `task ID`` is the key and most of the time it is the only actor to operate with the new API. 

In version {VERSION_911}, the General Process API entrypoints are based on the following pattern:

`http://<host:port>/<process id>/<process
instance>/<task name>/<task instance id>`

In version {VERSION} the User Task API entrypoints are based on the following pattern:

`http://<host:port>/<usertasks>/<instance>/<task instance id>`

[NOTE]
====
The Task ID used in the User Tasks is not the same ID required in the Process API. The reason for this behavior is that the new API relies on a new subsystem. The subsystem base has its own IDs, that are not recognized by the Process API. This is an important point to understand before you start migrating to the new API. 

For example the `<task instance id>` referenced in the General Process API call:

`http://<host:port>/<process id>/<process
instance>/<task name>/<task instance id>`

and

`http://<host:port>/usertasks/instance/<task instance id>`
====

You must upgrade all entry points in your application to use the User Task API layers when operating with User Tasks. 

The Returned JSON object contains more detailed data. You will therefore need to adapt how the entrypoint data is consumed by your application.

The following sections show how the API calls changed based
on the most important use cases:

[cols=",",]
|===
2+| *Example 1 - Show Tasks assigned to a user / groups*

|*Process API* |curl -X GET ++\++

'http://localhost:8080/++{++processId}/++{++uuid}/tasks?user=manager&group=managers'

|*User Task API* a|
curl -X GET ++\++

'http://localhost:8080/usertasks/instance?group=managers&user=manager'

2+|*Example 2 - Show a precise Task assigned to a user / groups*

|*Process API* a|
curl -X GET ++\++

'http://localhost:8080__/++{++__processId__}/++{++__processInstance__}/__++{++taskName}/++{++taskId}?user=manager'

|*New API* a|
curl -X GET ++\++

'http://localhost:8080/usertasks/instance/++{++taskId}?group=managers&user=manager'
|===

The JSON returned by the User Task API to represent a Task is significantly different from the JSON returned by the Process API.

Here, an example of the two returned objects for both endpoints.

The new User Tasks API returns the following information:

[source,json,subs="attributes+"]
----
{
    "id": "e447c247-abc2-4ed4-a7ab-ef4ee2fe4a71",
    "userTaskId": "_8B62D3CA-5D03-4B2B-832B-126469288BB4", // UserTask ID Node
    "status": {
      "terminate": null,
      "name": "Reserved" //phase
    },
    "taskName": "firstLineApproval",
    "taskDescription": null,
    "taskPriority": null,
    "potentialUsers": [
      "manager"
    ],
    "potentialGroups": [
      "managers"
    ],
    "adminUsers": [],
    "adminGroups": [],
    "excludedUsers": [],
    "externalReferenceId": "c7f40ec0-0272-4e04-9f0b-91ffe78d2590", 
    "actualOwner": "manager",
    "inputs": {
      "traveller": {
        "firstName": "John",
        "lastName": "Doe",
        "email": "jon.doe@example.com",
        "nationality": "American",
        "address": {
          "street": "main street",
          "city": "Boston",
          "zipCode": "10005",
          "country": "US"
        }
      }
    },
    "outputs": {},
    "metadata": {
      "ProcessType": "BPMN",
      "ParentProcessInstanceId": null,
      "ProcessVersion": "1.0",
      "RootProcessInstanceId": null,
      "RootProcessId": null,
      "ProcessId": "approvals",
      "ProcessInstanceId": "e7822e65-abf3-4356-9cf9-15bde2c43641",
      "ProcessInstanceState": 1
    }
  }

----

While the Process API returns the following task information:

[source,json,subs="attributes+"]
----
[
  {
    "id": "c7f40ec0-0272-4e04-9f0b-91ffe78d2590",
    "name": "firstLineApproval",
    "state": 1, // termination state
    "phase": "activate",
    "phaseStatus": "Activated",
    "parameters": {
      "traveller": {
        "firstName": "John",
        "lastName": "Doe",
        "email": "jon.doe@example.com",
        "nationality": "American",
        "address": {
          "street": "main street",
          "city": "Boston",
          "zipCode": "10005",
          "country": "US"
        }
      }
    },
    "results": {
      "approved": null
    }
  }
]
----

The main differences are:

* The User Tasks IDs will not be the same.
+
The assigned ID for the Task in the new User Tasks API
(e447c247-abc2-4ed4-a7ab-ef4ee2fe4a71) is scoped inside the User Tasks
subsystem, and can only be used in that subsystem. It is the ID to be used as taskID parameter in all the
entrypoints defined in the new User Tasks API. The rest of the engine is
out of scope. Using this task ID in a Process API entrypoint
will lead to an error.

* The `externalReferenceId` element represents the Work Item ID, which is how the Process API identifies a User Task at the global level. The value is the same as the Task ID if you use Process API. 

* New data related to the assigned permissions for the Tasks
has been added, such as the actual owner, potential users and groups and excluded users

* The `parameters` object present in the old API has become `inputs` and `outputs`. These represents a Map of String, Objects entries that you can set
as the User Task input or output. You can modify this list adding more entries with a specific entrypoint.

* The new API Task object now contains a Metadata object. This contains relevant properties that describes the BPMN asset 

With the dedicated API for User Tasks, it is now possible to directly put new Input and Output data for a given User Task, using the following entrypoints:

[cols=",",]
|===
2+|*Example 3 – Add Inputs data*

|*Process API* |Not possible to modify inputs in the previous API
version.

|*New API* a|
curl -X PUT ++\++

'http://localhost:8080/usertasks/instance/++{++taskId}/inputs?group=managers&user=manager'++\++

-H 'accept: application/json' ++\++

-H 'Content-Type: application/json' ++\++

-d '++{++

"variable": "value"

}'

2+| *Example 4 - Add Output data*

|*Process API* |Not possible to pass Output data to a User Task when sending a termination (eg. completion) phase update call.

|*New API* a|
curl -X PUT ++\++

'http://localhost:8080/usertasks/instance/++{++taskId}/outputs?group=managers&user=manager'
++\++

-H 'accept: application/json' ++\++

-H 'Content-Type: application/json' ++\++

-d '++{++

"variable": "value"

}'
|===

Here are some examples on how to manage Comments and Attachments

[cols=",",]
|===
2+|*Example 5  Add Comments*

|*Process API* |Not possibile to add comments

|*New API* a|
curl -X POST ++\++

'http://localhost:8080/usertasks/instance/++{++taskId}/comments?
group=managers&user=manager' ++\++

-H 'accept: application/json' ++\++

-H 'Content-Type: application/json' ++\++

-d '++{++

"comment": "test"

}'

2+| *Example 6 - Add Attachments*

|*Process API* |Not possibile to add attachments

|*New API* a|
curl -X POST ++\++

'http://localhost:8080/usertasks/instance/++{++taskId}/attachments?group=managers&user=manager'
++\++

-H 'accept: application/json' ++\++

-H 'Content-Type: application/json' ++\++

-d '++{++

"uri": "http://www.bamoe.com",
"name": "bamoe"

}'
|===

Similar operations (GET, DELETE) can be performed against Comments and
Attachments. The precise endpoint definitions are shown above.

The following examples show how to apply a transition to a
given User Task.
The transition scope is to advance a User Task status, moving it from
one status to another (transitionID), where the status can be: "activate", "claim", "release", "complete", "skip", or “fail”. The following example shows
how to complete a User Task.

[cols=",",]
|===
2+|*Example 7 - Approve User Task*

|*Process API* a|
curl -X POST ++\++
'http://localhost:8080/++{++processId}/++{++uuid}/++{++taskName}/++{++taskId}?user=admin&group=managers'
++\++

-H 'accept: application/json' ++\++

-H 'Content-Type: application/json' ++\++

-d '++{++

"approved": "true"

}'

OR

curl -X POST ++\++
'http://localhost:8080/++{++processId}/++{++uuid}/++{++taskName}/++{++taskId}/phases/++{++phaseId}?user=admin&group=managers'
++\++

-H 'accept: application/json' ++\++

-H 'Content-Type: application/json' ++\++

-d '++{++

"approved": "true"

}'

|*New API* a|
curl -X POST ++\++

'http://localhost:8080/usertasks/instance/++{++taskId}/transition?group=managers&user=manager'
++\++

-H 'accept: application/json' ++\++

-H 'Content-Type: application/json' ++\++

-d '++{++

"transitionId": "complete"

}' 
|===

With the Process API there are two ways to change the
User Task status. With the first entrypoint, the User Tasks change its
status to complete, without specifying the phaseId. The second
entrypoint gives the ability to pass a specific phaseId different than
“complete”. It is possible to pass output values in the same call (E.g.,
“approved” = true)

The new User Task API requires that the transitionID is defined in the
JSON payload, as in the example below. It is no longer possible to pass
output values as was done in the Process API, so if you need to put some output
data, you need to call the Add Output entypoint described later.

A new feature that the new User Tasks API introduced is to provide an
endpoint that returns all reachable statuses that a given User Task can
reach from the current status.

[cols=",",]
|===
2+|*Example 8 – Retrieve reachable status for a given User Task*

|*Process API* |Not present

|*New API* a|
curl -X GET ++\++

'http://localhost:8080/usertasks/instance/++{++taskId}/transition?
group=managers&user=manager' ++\++
|===

=== Migrating your PostgreSQL database
The database script package contain scripts that enable you to migrate a database that you set up with the technology preview for stateful workflow.