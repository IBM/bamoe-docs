= Decisions and Rules services with Spring Boot
include::../partials/attributes.adoc[]

You can create a Business Service using Decision and Rule engine with the Spring Boot framework support.

== DMN business services with Spring Boot

During the compilation, some code is automatically generated by a specific Maven plugin where part of the code is common and rest of it is engine-specific.
For each model, REST endpoints are generated, that are specific to the model and the engine.

Developers can add custom classes to the Business Service project to provide additional functionality, which will be built with the automatically generated code as in normal Java applications.

=== Dependencies

The dependencies required for a decision application with Spring Boot are:

[source]
----
org.drools:drools-decisions-spring-boot-starter
org.springframework.boot:spring-boot-starter-actuator
----

The two dependencies also transitively bring in all the other needed dependencies.
Beside the listed ones, there are other dependencies a user might add for development purposes, for example, tests, and development support.
These may include:

[source]
----
org.kie.kogito:kogito-scenario-simulation
----
This is needed to embed SCESIM testing functionality

[source]
----
org.springframework.boot:spring-boot-devtools
----
This is needed to enable hot-reload during development

Finally, the following plugins are required to correctly build and package the application:

[source]
----
org.kie.kogito:kogito-maven-plugin
org.springframework.boot:spring-boot-maven-plugin
----

=== Setup

The core of the Business Service application configuration is inside the root POM.
First of all, the BAMOE target version must be identified.

Then, there is a Bill of Materials (BOM) that is used to simplify dependency management, to be declared in the dependencyManagement section, enabling you to control dependencies and their versions via the BOM without changing the POM file. 

[source]
----
org.kie.kogito:kogito-spring-boot-bom
org.springframework.boot:spring-boot-devtools
----

Here is an example of a POM with SCESIM and devtools support:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>

<groupId>org.kie.kogito.demos</groupId>
<artifactId>dmn-springboot-demo</artifactId>
<version>1.0-SNAPSHOT</version>

  <properties>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <version.bamoe.bom>9.2.0-ibm-0004</version.bamoe.bom>
    <version.org.springframework.boot>3.4.3</version.org.springframework.boot>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.kie.kogito</groupId>
        <artifactId>kogito-spring-boot-bom</artifactId>
        <version>${version.bamoe.bom}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <version>${version.org.springframework.boot}</version>
        <optional>true</optional>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-devtools</artifactId>
      <optional>true</optional>
    </dependency>
    <dependency>
      <groupId>org.drools</groupId>
      <artifactId>drools-decisions-spring-boot-starter</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>io.rest-assured</groupId>
      <artifactId>rest-assured</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.kie.kogito</groupId>
      <artifactId>kogito-scenario-simulation</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <finalName>${project.artifactId}</finalName>
    
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.kie.kogito</groupId>
          <artifactId>kogito-maven-plugin</artifactId>
          <version>${version.bamoe.bom}</version>
        </plugin>
        <plugin>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-maven-plugin</artifactId>
          <version>${version.org.springframework.boot}</version>
        </plugin>
      </plugins>
    </pluginManagement>

    <plugins>
      <plugin>
        <groupId>org.kie.kogito</groupId>
        <artifactId>kogito-maven-plugin</artifactId>
        <executions>
          <execution>
            <phase>compile</phase>
            <goals>
              <goal>generateModel</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>repackage</goal>
            </goals>
          </execution>
        </executions>
        </plugin>
      </plugins>
  </build>
</project>
----

Beside the POM, the `application.properties` file is required to further customize the application with Spring Boot or BAMOE specific properties (for example, server.address).

Lastly, a `logback.xml` file should be provided to customize logging output.

=== Structure

A Decision application has the usual Maven structure
(module).

[source]
----
  src/
    main/
      /java
      /resources
    test/
      /java
      /resources
----

Model(s), `application.properties` and `logback.xml` files have to be written in the `main/resource directory` (to change the behavior during test execution, `application.properties` and `logback.xml` could also be written in `test/resources`).

Generated code will be generated in `target/generated-sources/kogito`.

=== Code

As in all Spring Boot applications, an entry point class annotated with `@SpringBootApplication` is required. This is a simple example:

[source,java]
----
@SpringBootApplication(scanBasePackages = { "org.kie.kogito.dmn.**", "org.kie.kogito.app.**", "http**" })
public class KogitoSpringbootApplication {
    public static void main(String[] args) {
        SpringApplication.run(KogitoSpringbootApplication.class, args);
    }
}

----

=== Testing

For full integration tests, testing classes should be annotated as `@SpringBootTest`, eventually injecting required managed properties or beans.

Here is an example that verifies the response received when posting an HTTP request on a given (automatically generated) entry point:

[source,java]
----
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = KogitoSpringbootApplication.class)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
public class TrafficViolationTest {

    @LocalServerPort
    private int port;

    @BeforeEach
    public void setUp() {
        RestAssured.port = port;
    }

    @Test
    public void testEvaluateTrafficViolation() {
        given()
                .body("{\n" +
                        "    \"Driver\": {\n" +
                        "        \"Points\": 2\n" +
                        "    },\n" +
                        "    \"Violation\": {\n" +
                        "        \"Type\": \"speed\",\n" +
                        "        \"Actual Speed\": 120,\n" +
                        "        \"Speed Limit\": 100\n" +
                        "    }\n" +
                        "}")
                .contentType(ContentType.JSON)
                .when()
                .post("/Traffic Violation")
                .then()
                .statusCode(200)
                .body("'Should the driver be suspended?'", is("No"));
    }
}

----

=== SCESIM

Scenario Simulation (SCESIM) is a testing tool used to verify the response of the decision engine following a series of invocations. It uses a `*.scesim` file that describes all the tested scenarios. 

The file may be created or edited using the Decision editor, and should be saved in the `test/resources` folder. 

In addition, a runner class is required in the `src/test/java/testscenario` package; here is an example:

[source,java]
----
@org.junit.runner.RunWith(org.kogito.scenariosimulation.runner.KogitoJunitActivator.class)
public class KogitoScenarioJunitActivatorTest { }
----

=== Compilation

During Maven’s compilation phase, the `kogito-maven-plugin` scans the `main/resources` directory to find any `*.dmn` files. 

For each discovered file, the decision engine creates REST classes, with endpoints specifically to:

.	Retrieve the original model
.	Execute the model
. Execute the model and retrieve “explanation” information

The classes are generated in a package whose name reflects the namespace of the dmn file, while the name of the generated class, and the endpoint root, is derived from the name of the model itself.

=== Testing

During Maven’s test phase, all the scenarios defined in the SCESIM file are executed as a single unit test, and the results are saved in the `target/surefire-reports` folder. 

At the same time, all other unit tests and integration tests are executed and their results are stored in the same folder.

=== Execution during development

The following Maven command will compile from scratch and start the Spring Boot application:

[source,shell]
----
mvn clean compile spring-boot:run
----

After a successful start, the application will be available at `\http://:0.0.0.0:8080` address (IP depends on application.properties configuration).

The swagger-ui page (`\http://0.0.0.0:8080/swagger-ui/index.html`) shows all the generated endpoints, providing a way to quickly verify them.

The following command might be used to simply compile and test the application, without starting it:

[source,shell]
----
mvn clean verify
----

=== Hot-reload

For medium to large sized applications, recompiling and restarting the application upon code changes could be cumbersome and time-consuming. To simplify that, the Spring Boot framework offers https://docs.spring.io/spring-boot/docs/3.2.6/reference/html/using.html#using.devtools[devtools].

The condition is that the classpath has to be "manually" rebuilt to trigger the reload. 

Since the Business Service application also relies on automatic code-generation driven by models and executed by the 'kogito-maven-plugin', the approach is to:

.	Create a mvn clean compile command/button (details vary by IDE) to be fired on-demand.
.	Start the application with mvn clean compile spring-boot:run.
.	Execute the command at point 1 when it is required to reload changes.

=== Debugging

The way to debug the application without using specific IDE tools or plug-ins, relies on the standard Java remote debug setup:

.	Create a remote debug configuration on port 8000 (details vary by IDE).
.	Start application in debug mode.
+
[source,shell]
----
mvn clean compile spring-boot:run -Dspring-boot.run.jvmArguments="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000"
----
+
.	Put a breakpoint in some of the code-generated sources.
. Connect the remote debugger.

=== Package and run

Standard Maven or Java commands are required to package and start the generated application. Following are the commands:

.	`mvn clean package`
.	`java -jar ./target/(name_of_the_application).jar`


== DRL business services with Spring Boot

During the compilation, some code is automatically generated by a specific Maven plugin where part of the code is common and rest of it is engine-specific.
For each model, REST endpoints are generated, that are specific to the model and the engine.

Developers can add custom classes to the BAMOE application to provide additional functionality, which will be built with the automatically generated code as in normal Java applications.

=== Dependencies

The dependencies required for a decision application with Spring Boot support are:

[source]
----
org.drools:drools-rules-spring-boot-starter
org.springframework.boot:spring-boot-starter-actuator
----

The two dependencies also transitively bring in all the other needed dependencies.
Beside the listed ones, there are other dependencies a user might add for development purposes, for example, tests, and development support.
These may include:

[source]
----
org.springframework.boot:spring-boot-devtools
----
This is needed to enable hot-reload during development

Finally, the following plugins are required to correctly build and package the application:

[source]
----
org.kie.kogito:kogito-maven-plugin
org.springframework.boot:spring-boot-maven-plugin
----

=== Setup

The core of the BAMOE application configuration is inside the root POM.
First of all, the BAMOE target version must be identified.

Then, there is a Bill of Materials (BOM) that is used to simplify dependency management, to be declared in the dependencyManagement section, enabling you to control dependencies and their versions via the BOM without changing the POM file. 

[source]
----
org.kie.kogito:kogito-spring-boot-bom
org.springframework.boot:spring-boot-devtools
----

Here is an example of a pom with devtools support:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>org.kie.kogito.demos</groupId>
  <artifactId>drl-springboot-demo</artifactId>
  <version>1.0-SNAPSHOT</version>

  <properties>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <version.bamoe.bom>9.2.0-ibm-0004</version.bamoe.bom>
    <version.org.springframework.boot>3.4.3</version.org.springframework.boot>
  </properties>

  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.kie.kogito</groupId>
        <artifactId>kogito-spring-boot-bom</artifactId>
        <version>${version.bamoe.bom}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <version>${version.org.springframework.boot}</version>
        <optional>true</optional>
      </dependency>
    </dependencies>
  </dependencyManagement>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-devtools</artifactId>
      <optional>true</optional>
    </dependency>
    <dependency>
      <groupId>org.drools</groupId>
      <artifactId>drools-rules-spring-boot-starter</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>io.rest-assured</groupId>
      <artifactId>rest-assured</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <finalName>${project.artifactId}</finalName>

    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.kie.kogito</groupId>
          <artifactId>kogito-maven-plugin</artifactId>
          <version>${version.bamoe.bom}</version>
        </plugin>
        <plugin>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-maven-plugin</artifactId>
          <version>${version.org.springframework.boot}</version>
        </plugin>
      </plugins>
    </pluginManagement>

    <plugins>
      <plugin>
        <groupId>org.kie.kogito</groupId>
        <artifactId>kogito-maven-plugin</artifactId>
        <executions>
          <execution>
            <phase>compile</phase>
            <goals>
              <goal>generateModel</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>repackage</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>
----

Beside the POM, the `application.properties` file is required to further customize the application with Spring Boot or BAMOE specific properties (for example, server.address).

Lastly, a `logback.xml` file should be provided to customize logging output.

=== Structure

A Rule application has the usual Maven structure
(module).

[source]
----
  src/
    main/
      /java
      /resources
    test/
      /java
      /resources
----

Model(s), `application.properties` and `logback.xml` files have to be written in the `main/resource directory` (to change the behavior during test execution, `application.properties` and `logback.xml` could also be written in `test/resources`).

Generated code will be generated in `target/generated-sources/kogito`.

=== Code

As in all Spring Boot applications, an entry point class annotated with `@SpringBootApplication` is required. This is a simple example:

[source,java]
----
@SpringBootApplication(scanBasePackages = { "org.kie.kogito.**", "org.drools.**" })
public class KogitoSpringbootApplication {
    public static void main(String[] args) {
        SpringApplication.run(KogitoSpringbootApplication.class, args);
    }
}

----

Beside the `SpringBoot` entry point, rule engine may require additional java classes that are declared and used inside the DRL model.


=== Testing

For full integration tests, testing classes should be annotated as `@SpringBootTest`, eventually injecting required managed properties or beans.

Here is an example that verifies the response received when posting an HTTP request on a given (automatically generated) entry point:

[source,java]
----
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = KogitoSpringbootApplication.class)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
public class RestQueryTest {

    @LocalServerPort
    private int port;

    @BeforeEach
    public void setUp() {
        RestAssured.port = port;
    }

    private static final String JSON_PAYLOAD =
            "{\n" +
                    "  \"maxAmount\":5000,\n" +
                    "  \"loanApplications\":[\n" +
                    "    {\n" +
                    "      \"id\":\"ABC10001\",\n" +
                    "      \"amount\":2000,\n" +
                    "      \"deposit\":100,\n" +
                    "      \"applicant\":{\n" +
                    "        \"age\":45,\n" +
                    "        \"name\":\"John\"\n" +
                    "      }\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"id\":\"ABC10002\",\n" +
                    "      \"amount\":5000,\n" +
                    "      \"deposit\":100,\n" +
                    "      \"applicant\":{\n" +
                    "        \"age\":25,\n" +
                    "        \"name\":\"Paul\"\n" +
                    "      }\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"id\":\"ABC10015\",\n" +
                    "      \"amount\":1000,\n" +
                    "      \"deposit\":100,\n" +
                    "      \"applicant\":{\n" +
                    "        \"age\":12,\n" +
                    "        \"name\":\"George\"\n" +
                    "      }\n" +
                    "    }\n" +
                    "  ]\n" +
                    "}";

    @Test
    public void testApproved() {
        given()
                .body(JSON_PAYLOAD)
                .contentType(ContentType.JSON)
                .when()
                .post("/find-approved")
                .then()
                .statusCode(200)
                .body("id", hasItem("ABC10001"));
    }
}

----

=== Compilation

During Maven’s compilation phase, the `kogito-maven-plugin` scans the `main/resources` directory to find any `*.drl` files. For each discovered file, the rule engine creates REST classes, with endpoints specific to execute the model.

The classes are generated in a package of the `drl` file.

=== Testing

During Maven’s test phase, all the unit tests and integration tests are executed and their results are stored in the `target/surefire-reports` folder.

=== Execution during development

The following Maven command will compile from scratch and start the Spring Boot application:

[source,shell]
----
mvn clean compile spring-boot:run
----

After a successful start, the application will be available at `\http://:0.0.0.0:8080` address (IP depends on application.properties configuration).

The swagger-ui page (`\http://0.0.0.0:8080/swagger-ui/index.html`) shows all the generated endpoints, providing a way to quickly verify them.

The following command might be used to simply compile and test the application, without starting it:

[source,shell]
----
mvn clean verify
----

=== Hot-reload

For medium to large sized applications, recompiling and restarting the application upon code changes could be cumbersome and time-consuming. To simplify that, the Spring Boot framework offers https://docs.spring.io/spring-boot/docs/3.2.6/reference/html/using.html#using.devtools[devtools].

The condition is that the classpath has to be "manually" rebuilt to trigger the reload. 

Since the BAMOE application also relies on automatic code-generation driven by models and executed by the 'kogito-maven-plugin', the approach is to:

.	Create a mvn clean compile command/button (details vary by IDE) to be fired on-demand.
.	Start the application with mvn clean compile spring-boot:run.
.	Execute the command at point 1 when it is required to reload changes.

=== Debugging

The way to debug the application without using specific IDE tools or plug-ins, relies on the standard Java remote debug setup:

.	Create a remote debug configuration on port 8000 (details vary by IDE).
.	Start application in debug mode:
+
[source,shell]
----
mvn clean compile spring-boot:run -Dspring-boot.run.jvmArguments="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000"
----
+
.	Put a breakpoint in some of the code-generated sources.
. Connect the remote debugger.

=== Package and run

Standard Maven or Java commands are required to package and start the generated application. Following are the commands:

.	`mvn clean package`
.	`java -jar ./target/(name_of_the_application).jar`

