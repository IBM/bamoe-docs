= Decisions and Rules services with Spring Boot
include::../partials/attributes.adoc[]
include::../styles/images.adoc[]

You can create a _Business Service_ using the Decision and Rule engines with the Spring Boot framework support.

During the compilation, some code is automatically generated by a specific Maven plugin where part of the code is common and rest of it is engine-specific.

For each model, REST endpoints are generated, that are specific to the model and the engine.

Developers can add custom classes to the _Business Service_ project to provide additional functionality, which will be built with the automatically generated code as in normal Java applications.

== Dependencies

First, use the BAMOE BOM for easily managing the version of all BAMOE libraries, combined with the Spring Boot BOM.

[source,xml,subs="+attributes"]
----
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>com.ibm.bamoe</groupId>
      <artifactId>bamoe-bom</artifactId>
      <version>{BOM_VERSION}</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-devtools</artifactId>
      <version>{SPRING_BOOT_VERSION_BOM}</version>
      <optional>true</optional>
    </dependency>
  </dependencies>
</dependencyManagement>
----

The dependencies required for a Decision or Rules application with Spring Boot are:

[source,xml]
----
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<!-- and -->

<!-- For Decisions -->
<dependency>
  <groupId>org.drools</groupId>
  <artifactId>drools-decisions-spring-boot-starter</artifactId>
</dependency>

<!-- or -->

<!-- For Rules -->
<dependency>
  <groupId>org.drools</groupId>
  <artifactId>drools-rules-spring-boot-starter</artifactId>
</dependency>

----

To enable hot-reload during development, use

[source,xml]
----
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-devtools</artifactId>
</dependency>
----

To enable Test Scenario support, use

[source,xml]
----
<dependency>
  <groupId>org.kie.kogito</groupId>
  <artifactId>kogito-scenario-simulation</artifactId>
  <scope>test</scope>
</dependency>
----

Finally, the following Maven plugins are required to correctly build and package the application:

[source,xml]
----
<plugin>
  <groupId>org.kie.kogito</groupId>
  <artifactId>kogito-maven-plugin</artifactId>
</plugin>
<plugin>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
----


See the {BAMOE_DOCS_EXAMPLES_DOCS_LINK}/spring-boot/decisions/pom.xml[complete pom.xml for Decisions] for a _Business Servics_ with Decisions on Spring Boot, or {BAMOE_DOCS_EXAMPLES_DOCS_LINK}/spring-boot/rules/pom.xml[complete pom.xml for Rules] for a _Business Service_ with Rules on Spring Boot.

== Configuration

Beside the `pom.xml`, the `application.properties` file is required to further customize the application with Spring Boot or BAMOE specific properties (for example, `server.address`).

Lastly, a `logback.xml` file should be provided to customize logging output.

== Structure

Decision _Business Service_ projects follows https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html[Maven's standard  directory layout].

Decisions, `application.properties` and `logback.xml` files have to be written in the `src/main/resources`` directory.

To change the behavior during test execution, `application.properties` and `logback.xml` could also be written in `src/test/resources`.

Generated code will be in `target/generated-sources/kogito`.

== Code

Decisions (DMN) and Rules (DRL) files need to go in the `src/main/resources` directory. And as in all Spring Boot applications, an entry point class annotated with `@SpringBootApplication` is required. 

For Decisions:

[source,java]
----
@SpringBootApplication(scanBasePackages = { "org.kie.kogito.dmn.**", "org.kie.kogito.app.**", "http**" })
public class KogitoSpringbootApplication {
    public static void main(String[] args) {
        SpringApplication.run(KogitoSpringbootApplication.class, args);
    }
}
----

or for Rules:

[source,java]
----
@SpringBootApplication(scanBasePackages = { "org.kie.kogito.**", "org.drools.**" })
public class KogitoSpringbootApplication {
    public static void main(String[] args) {
        SpringApplication.run(KogitoSpringbootApplication.class, args);
    }
}
----

== Testing

For full integration tests, testing classes should be annotated as `@SpringBootTest`, eventually injecting required managed properties or beans.

Here is an example that verifies the response received when posting an HTTP request on a given (automatically generated) entry point for a Decision:

[source,java]
----
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = KogitoSpringbootApplication.class)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
public class TrafficViolationTest {

    @LocalServerPort
    private int port;

    @BeforeEach
    public void setUp() {
        RestAssured.port = port;
    }

    @Test
    public void testEvaluateTrafficViolation() {
        given()
                .body("{\n" +
                        "    \"Driver\": {\n" +
                        "        \"Points\": 2\n" +
                        "    },\n" +
                        "    \"Violation\": {\n" +
                        "        \"Type\": \"speed\",\n" +
                        "        \"Actual Speed\": 120,\n" +
                        "        \"Speed Limit\": 100\n" +
                        "    }\n" +
                        "}")
                .contentType(ContentType.JSON)
                .when()
                .post("/Traffic Violation")
                .then()
                .statusCode(200)
                .body("'Should the driver be suspended?'", is("No"));
    }
}
----

or for Rules:

[source,java]
----
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = KogitoSpringbootApplication.class)
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
public class RestQueryTest {

    @LocalServerPort
    private int port;

    @BeforeEach
    public void setUp() {
        RestAssured.port = port;
    }

    private static final String JSON_PAYLOAD =
            "{\n" +
                    "  \"maxAmount\":5000,\n" +
                    "  \"loanApplications\":[\n" +
                    "    {\n" +
                    "      \"id\":\"ABC10001\",\n" +
                    "      \"amount\":2000,\n" +
                    "      \"deposit\":100,\n" +
                    "      \"applicant\":{\n" +
                    "        \"age\":45,\n" +
                    "        \"name\":\"John\"\n" +
                    "      }\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"id\":\"ABC10002\",\n" +
                    "      \"amount\":5000,\n" +
                    "      \"deposit\":100,\n" +
                    "      \"applicant\":{\n" +
                    "        \"age\":25,\n" +
                    "        \"name\":\"Paul\"\n" +
                    "      }\n" +
                    "    },\n" +
                    "    {\n" +
                    "      \"id\":\"ABC10015\",\n" +
                    "      \"amount\":1000,\n" +
                    "      \"deposit\":100,\n" +
                    "      \"applicant\":{\n" +
                    "        \"age\":12,\n" +
                    "        \"name\":\"George\"\n" +
                    "      }\n" +
                    "    }\n" +
                    "  ]\n" +
                    "}";

    @Test
    public void testApproved() {
        given()
                .body(JSON_PAYLOAD)
                .contentType(ContentType.JSON)
                .when()
                .post("/find-approved")
                .then()
                .statusCode(200)
                .body("id", hasItem("ABC10001"));
    }
}
----


== Compilation

During Maven’s compilation phase, `kogito-maven-plugin` scans the `src/main/resources` directory to find any `.dmn` or `.drl` files. 

For each discovered file, the decision engine creates REST Resource classes, with endpoints specifically to:

.	Retrieve the original model
.	Execute the model
. Execute the model and retrieve “explanation” information

The classes are generated in a package whose name reflects the namespace of the DMN files, while the name of the generated class and the endpoint root are derived from the name of the model itself. For Rules, the classes are generated in the package of the DRL file.

== Execution in dev mode

The following Maven command will compile from scratch and start the Spring Boot application in dev mode:

[source,shell]
----
mvn clean compile spring-boot:run
----

After a successful start, the application will be available at `\http://:0.0.0.0:8080` address (IP depends on `application.properties` configuration).

The Swagger UI page (`\http://0.0.0.0:8080/swagger-ui/index.html`) shows all the generated endpoints, providing a way to quickly verify them.

== Hot-reload in dev-mode

For medium to large sized applications, recompiling and restarting the application upon code changes could be cumbersome and time-consuming. To simplify that, the Spring Boot framework offers https://docs.spring.io/spring-boot/3.4/reference/using/devtools.html[devtools].

The condition is that the classpath has to be "manually" rebuilt to trigger the reload. 

Since _Business Services_ also relies on automatic code-generation driven by models and executed by the 'kogito-maven-plugin', the approach is to:

.	Create a mvn clean compile command/button (details vary by IDE) to be fired on-demand.
.	Start the application with `mvn clean compile spring-boot:run`.
.	Execute the command at point 1 when it is required to reload changes.

== Debugging

The way to debug the application without using specific IDE tools or plug-ins, relies on the standard Java remote debug setup:

.	Create a remote debug configuration on port 8000 (details vary by IDE).
.	Start application in debug mode.
+
[source,shell]
----
mvn clean compile spring-boot:run -Dspring-boot.run.jvmArguments="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000"
----
+
.	Put a breakpoint in some of the code-generated sources.
. Connect the remote debugger.

